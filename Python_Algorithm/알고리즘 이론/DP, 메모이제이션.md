## DP(Dynamic Programing)
  * 동적 계획법
  * 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하는 방법.
  * 탑다운(top-down) 과 보텁업(bottom-up), 두 가지 방식으로 구성
  * 조건
    - 최적 부분 구조: 큰 문제를 작은 문제로 나눌 수 있고, 작은 문제의 답을 모아서 큰 문제를 해결 할 수 있는 경우
    - 중복되는 부분 문제: 동일한 작은 문제를 반복적으로 해결해야함.

## 메모이제이션
  * 한 번 계산한 결과를 메모리 공간에 메모하는 기법
    - 캐싱: 값을 기록해 놓는다
    - 같은 문제를 다시 호출하면, 메모 했던 결과를 그대로 가져온다
  * 다이나믹 프로그래밍에 국한된 개념은 아님
    - 이전 계산 결과를 일시적으로 기록해 놓는 넓은 개념을 의미

## 탑다운 & 보터멉
  * 탑다운(메모이제이션) 방식은 하향식, 보텀업 방식은 상향식이라고도 함
  * 보텀업 방식은 전형적인 dp방식
    - dp테이블(결과 저장용 리스트) 이용

## 예제: 피보나치 수열
   1. 탑다운
```python
# 메모이제이션을 위한 리스트 초기화
dp = [0] * 100

# 재귀함수 구현
def fibo(x):
    # 종료 조건
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제면 그대로 반환
    if dp[x] != 0:
        return dp[x]
    # 계산한 적 없다면, 함수 결과 반환
    dp[x] = fibo(x - 1) + fibo(x - 2)
    return dp[x]
  
  print(fibo(99))
  ```
   2. 보텀업
  ```python
  # dp 테이블 초기화
  dp = [0] * 100
  
  # 첫 번째와 두 번째 값은 1
  dp[1] = 1
  dp[2] = 1
  n = 99
  
  # 반복문으로 구현(보텀업 다이나믹 프로그래밍)
  for i in range(3, n + 1):
      dp[i] = dp[i - 1] + dp[i - 2]
  
  print(dp[n])
  ```
 ## 분할 정복과의 차이
   * DP와 분할정복은 모두 최적 부분 구조를 가질 때 사용 가능
   * 하지만 **부분 문제의 중복**에서 차이
     - DP: 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복
     - 분할 정복: 동일한 부분 문제가 반복적으로 계산 되지 않음
 
 ---
 LCS 문제는 메모이제이션을 이용한 대표적인 중~고난도 문제이며 메모이제이션을 이해하는데 매우 효과적이다.
 아래의 유튜브 해설을 통해 메모이제이션에 대해 충분히 이해하자.
 https://youtu.be/sSno9rV8Rhg

 
